<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>c++ Lambda表达式 | Phoenix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Lambda 表达式C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ Lambda表达式">
<meta property="og:url" content="http://yoursite.com/2022/07/17/c++%20Lambda/index.html">
<meta property="og:site_name" content="Phoenix">
<meta property="og:description" content="Lambda 表达式C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-17T07:54:04.109Z">
<meta property="article:modified_time" content="2022-07-17T07:54:04.109Z">
<meta property="article:author" content="Phoenix">
<meta property="article:tag" content="learn">
<meta property="article:tag" content="Program">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/phoenixwxy.github.io/atom.xml" title="Phoenix" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/phoenixwxy.github.io/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/phoenixwxy.github.io/" id="logo">Phoenix</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/phoenixwxy.github.io/">Home</a>
        
          <a class="main-nav-link" href="/phoenixwxy.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/phoenixwxy.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-c++ Lambda" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/phoenixwxy.github.io/2022/07/17/c++%20Lambda/" class="article-date">
  <time datetime="2022-07-17T07:54:04.109Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/phoenixwxy.github.io/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++ Lambda表达式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/11">Python</a>等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。</p>
<span id="more"></span>
<h2 id="声明Lambda表达式"><a href="#声明Lambda表达式" class="headerlink" title="声明Lambda表达式"></a><strong>声明Lambda表达式</strong></h2><p>Lambda表达式完整的声明格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>各项具体含义如下</p>
<ol>
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：用来说用是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[capture list] (params list) -&gt; return type {function body}</td>
</tr>
<tr>
<td>2</td>
<td>[capture list] (params list) {function body}</td>
</tr>
<tr>
<td>3</td>
<td>[capture list] {function body}</td>
</tr>
</tbody>
</table>
</div>
<p>其中：</p>
<ul>
<li><p>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</p>
</li>
<li><p>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</p>
</li>
<li><p>格式3中省略了参数列表，类似普通函数中的无参函数。</p>
<p>  讲了这么多，我们还没有看到Lambda表达式的庐山真面目，下面我们就举一个实例。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; myvec&#123; 3, 2, 5, 7, 3, 2 &#125;;</span><br><span class="line">    vector&lt;int&gt; lbvec(myvec);</span><br><span class="line"></span><br><span class="line">    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法</span><br><span class="line">    cout &lt;&lt; &quot;predicate function:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int it : myvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;);   // Lambda表达式</span><br><span class="line">    cout &lt;&lt; &quot;lambda expression:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int it : lbvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p>
<p>下面，我们就重点介绍一下Lambda表达式各项的具体用法。</p>
<h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a><strong>捕获外部变量</strong></h2><p>Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p>
<p>我们通过一个例子来直观地说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    f(); // 输出：123</span><br><span class="line"></span><br><span class="line">    //或通过“函数体”后面的‘()’传入参数</span><br><span class="line">    auto x = [](int a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(123); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。</p>
<p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p>
<h4 id="1、值捕获"><a href="#1、值捕获" class="headerlink" title="1、值捕获"></a><strong>1、值捕获</strong></h4><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = 321;</span><br><span class="line">    f(); // 输出：123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。</p>
<h4 id="2、引用捕获"><a href="#2、引用捕获" class="headerlink" title="2、引用捕获"></a><strong>2、引用捕获</strong></h4><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&amp;。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = 321;</span><br><span class="line">    f(); // 输出：321</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p>
<h4 id="3、隐式捕获"><a href="#3、隐式捕获" class="headerlink" title="3、隐式捕获"></a><strong>3、隐式捕获</strong></h4><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p>
<p>隐式值捕获示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 值捕获</span><br><span class="line">    f(); // 输出：123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式引用捕获示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 引用捕获</span><br><span class="line">    a = 321;</span><br><span class="line">    f(); // 输出：321</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、混合方式"><a href="#4、混合方式" class="headerlink" title="4、混合方式"></a><strong>4、混合方式</strong></h4><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p>
<p>到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr>
<td>[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr>
<td>[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
</div>
<h2 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a><strong>修改捕获变量</strong></h2><p>前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 123;</span><br><span class="line">    auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // 不会报错</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; // 输出：123</span><br><span class="line">    f(); // 输出：124</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a><strong>Lambda表达式的参数</strong></h2><p>Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p>
<ol>
<li>参数列表中不能有默认参数</li>
<li>不支持可变参数</li>
<li>所有参数必须有参数名</li>
</ol>
<p>常用举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  &#123;　　　　 int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6; &#125;(5);</span><br><span class="line">       std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl;            　　//输出m:16</span><br><span class="line"></span><br><span class="line">       std::cout &lt;&lt; &quot;n:&quot; &lt;&lt; [](int x, int y) &#123; return x + y; &#125;(5, 4) &lt;&lt; std::endl;            //输出n:9</span><br><span class="line">       </span><br><span class="line">       auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;</span><br><span class="line">       auto lFunc = gFunc(4);</span><br><span class="line">       std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">       auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;</span><br><span class="line">       auto a = hFunc(gFunc(7), 8);</span><br><span class="line"></span><br><span class="line">       int a = 111, b = 222;</span><br><span class="line">       auto func = [=, &amp;b]()mutable &#123; a = 22; b = 333; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line"></span><br><span class="line">       func();</span><br><span class="line">       std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">       a = 333;</span><br><span class="line">       auto func2 = [=, &amp;a] &#123; a = 444; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">       func2();</span><br><span class="line"></span><br><span class="line">       auto func3 = [](int x) -&gt;function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;    　　</span><br><span class="line">　　　　 std::function&lt;void(int x)&gt; f_display_42 = [](int x) &#123; print_num(x); &#125;;</span><br><span class="line">f_display_42(44);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/07/17/c++%20Lambda/" data-id="cl5p1ft6k001etks65gg308ei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/phoenixwxy.github.io/tags/Program/" rel="tag">Program</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/phoenixwxy.github.io/tags/learn/" rel="tag">learn</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/phoenixwxy.github.io/2022/07/17/c++/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C++
        
      </div>
    </a>
  
  
    <a href="/phoenixwxy.github.io/2022/07/17/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android 系统的智能指针</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/Program/">Program</a></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/program/">program</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/program/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/program/CMake/">CMake</a></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/program/doc/">doc</a></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/program/git/">git</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/%E6%9F%A5%E8%AF%A2/">查询</a></li><li class="category-list-item"><a class="category-list-link" href="/phoenixwxy.github.io/categories/%E7%BC%96%E7%A8%8B/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/Effective/" rel="tag">Effective</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/Program/" rel="tag">Program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/backup/" rel="tag">backup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/c/" rel="tag">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/learn/" rel="tag">learn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/phoenixwxy.github.io/tags/shell/" rel="tag">shell</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/phoenixwxy.github.io/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/phoenixwxy.github.io/tags/C/" style="font-size: 13.33px;">C</a> <a href="/phoenixwxy.github.io/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/phoenixwxy.github.io/tags/Effective/" style="font-size: 10px;">Effective</a> <a href="/phoenixwxy.github.io/tags/Program/" style="font-size: 20px;">Program</a> <a href="/phoenixwxy.github.io/tags/backup/" style="font-size: 13.33px;">backup</a> <a href="/phoenixwxy.github.io/tags/c/" style="font-size: 10px;">c</a> <a href="/phoenixwxy.github.io/tags/c/" style="font-size: 16.67px;">c++</a> <a href="/phoenixwxy.github.io/tags/git/" style="font-size: 10px;">git</a> <a href="/phoenixwxy.github.io/tags/learn/" style="font-size: 20px;">learn</a> <a href="/phoenixwxy.github.io/tags/shell/" style="font-size: 10px;">shell</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/phoenixwxy.github.io/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/phoenixwxy.github.io/2022/07/17/regex/">Regex 正则表达式</a>
          </li>
        
          <li>
            <a href="/phoenixwxy.github.io/2022/07/17/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">内存对齐</a>
          </li>
        
          <li>
            <a href="/phoenixwxy.github.io/2022/07/17/%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83/">输出函数比较</a>
          </li>
        
          <li>
            <a href="/phoenixwxy.github.io/2022/07/17/git_submodule/">Git submodule</a>
          </li>
        
          <li>
            <a href="/phoenixwxy.github.io/2022/07/17/getopt/">getopt</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Phoenix<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/phoenixwxy.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/phoenixwxy.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/phoenixwxy.github.io/fancybox/jquery.fancybox.css">

  
<script src="/phoenixwxy.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/phoenixwxy.github.io/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>